Creation of emotion detector function
import requests, json

url = "https://sn-watson-emotion.labs.skills.network/v1/watson.runtime.nlp.v1/NlpService/EmotionPredict"
headers = {
    "grpc-metadata-mm-model-id": "emotion_aggregated-workflow_lang_en_stock"
}

def emotion_detector(text_to_analyze):
    input_json = {
        "raw_document": {
            "text": text_to_analyze
        }
    }

    # Call the API
    response = requests.post(url, headers=headers, json=input_json)
    result = response.json()

    # Extract emotions (anger, disgust, fear, joy, sadness)
    emotions = result['emotionPredictions'][0]['emotion']

    anger_score = emotions['anger']
    disgust_score = emotions['disgust']
    fear_score = emotions['fear']
    joy_score = emotions['joy']
    sadness_score = emotions['sadness']

    # Put them in a dictionary
    emotion_dict = {
        'anger': anger_score,
        'disgust': disgust_score,
        'fear': fear_score,
        'joy': joy_score,
        'sadness': sadness_score
    }
 # Find dominant emotion
    dominant_emotion = max(emotion_dict, key=emotion_dict.get)
    emotion_dict['dominant_emotion'] = dominant_emotion

    return emotion_dict

Unit test file
from emotionDetection.emotion_detection import emotion_detector
import unittest
class TestEmotionDetector(unittest.TestCase):
    def test_emotion_detector(self):
        
        result_1 = emotion_detector('I am glad this happened')
        self.assertEqual(result_1['dominant_emotion'], 'joy')
        
        result_2 = emotion_detector('I am really mad about this')
        self.assertEqual(result_2['dominant_emotion'], 'anger')
        
        result_3 = emotion_detector('I feel disgusted just hearing about this')
        self.assertEqual(result_3['dominant_emotion'], 'disgust')

        result_4 = emotion_detector("I am so sad about this")
        self.assertEqual(result_4['dominant_emotion'],'sadness')

        result_5 = emotion_detector("I am really afraid that this will happen")
        self.assertEqual(result_5['dominant_emotion'],'fear')

unittest.main()

Deployment of web application
from flask import Flask, render_template, request
from emotionDetection.emotion_detection import emotion_detector

app = Flask(__name__)

@app.route('/')
@app.route('/index')
def index():
    return render_template("index.html")

@app.route("/emotionDetector", methods=["GET"])
def emotionDetector():
    text = request.args.get("textToAnalyze")   
    result = emotion_detector(text)            

    response_text = (
        f"For the given statement, the system response is "
        f"'anger': {result['anger']}, 'disgust': {result['disgust']}, "
        f"'fear': {result['fear']}, 'joy': {result['joy']} and "
        f"'sadness': {result['sadness']}. "
        f"The dominant emotion is {result['dominant_emotion']}."
    )
    
    return f"<h2>{response_text}</h2>"

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000, debug=True)


Error handling(change in emotion_detection.py file)
import requests

url = "https://sn-watson-emotion.labs.skills.network/v1/watson.runtime.nlp.v1/NlpService/EmotionPredict"
headers = {
    "grpc-metadata-mm-model-id": "emotion_aggregated-workflow_lang_en_stock"
}

def emotion_detector(text_to_analyze):
    if not text_to_analyze.strip():  # Handle empty input directly
        return {
            "anger": None,
            "disgust": None,
            "fear": None,
            "joy": None,
            "sadness": None,
            "dominant_emotion": None
        }

    input_json = {"raw_document": {"text": text_to_analyze}}
    response = requests.post(url, headers=headers, json=input_json)

    if response.status_code == 400:  # Handle server error for blank input
        return {
            "anger": None,
            "disgust": None,
            "fear": None,
            "joy": None,
            "sadness": None,
            "dominant_emotion": None
        }

    result = response.json()
    emotions = result["emotionPredictions"][0]["emotion"]

    dominant_emotion = max(emotions, key=emotions.get)

    return {
        "anger": emotions["anger"],
        "disgust": emotions["disgust"],
        "fear": emotions["fear"],
        "joy": emotions["joy"],
        "sadness": emotions["sadness"],
        "dominant_emotion": dominant_emotion
    }


Error handling(change in server.py file)
from flask import Flask, render_template, request
from emotionDetection.emotion_detection import emotion_detector

app = Flask(__name__)

@app.route('/')
@app.route('/index')
def index():
    return render_template("index.html")

@app.route("/emotionDetector", methods=["GET"])
def emotionDetector():
    text = request.args.get("textToAnalyze")   
    result = emotion_detector(text)     
    if result["dominant_emotion"] is None:
        return "<h2>Invalid text! Please try again!</h2>"       

    response_text = (
        f"For the given statement, the system response is "
        f"'anger': {result['anger']}, 'disgust': {result['disgust']}, "
        f"'fear': {result['fear']}, 'joy': {result['joy']} and "
        f"'sadness': {result['sadness']}. "
        f"The dominant emotion is {result['dominant_emotion']}."
    )
    
    return f"<h2>{response_text}</h2>"

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000, debug=True)


Static_code_analysis( changes in server.py file)
"""
Flask server for Emotion Detector application.
Handles user input, runs emotion analysis, 
and renders the results in the web interface.
"""

from flask import Flask, request, render_template
from emotion_detection.emotion_detection import emotion_detector

app = Flask(__name__)


@app.route("/")
def index():
    """Render the homepage."""
    return render_template("index.html")


@app.route("/emotionDetector", methods=["POST"])
def emotion_detector_route():
    """
    Handle emotion detection requests.
    Supports both GET (via query params) and POST (via form data).
    """
    if request.method == "POST":
        text_to_analyze = request.form.get("textToAnalyze")
    else:
        text_to_analyze = request.args.get("textToAnalyze")

    result = emotion_detector(text_to_analyze)

    if result["dominant_emotion"] is None:
        return "<h2>Invalid text! Please try again!</h2>"

    response_text = (
        f"For the given statement, the system response is "
        f"'anger': {result['anger']}, "
        f"'disgust': {result['disgust']}, "
        f"'fear': {result['fear']}, "
        f"'joy': {result['joy']} and "
        f"'sadness': {result['sadness']}. "
        f"The dominant emotion is {result['dominant_emotion']}."
    )

    return f"<h2>{response_text}</h2>"


if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000)

